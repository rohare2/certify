#!/usr/bin/perl -w
###############################################################################
# $URL: file:///var/svn/cfengine/llnl/admin/scripts/ddndsh $
# $Author: jh $
# $Date: 2012-02-16 09:38:31 -0800 (Thu, 16 Feb 2012) $
# $Rev: 1594 $
###############################################################################
# Ned Bass
# Runs commands specified as arguments on DDN controllers
# via the telnet CLI.  Mimics pdsh usage and output style.
# Supports connecting to multiple controllers in parallel.

use lib "/opt/freeware/lib/site_perl";
use strict;
use Expect;
use Getopt::Std;

$Expect::Log_Stdout = 0; # Disable logging to STDOUT by default.

my $fanout	= 16;	# maximum active telnets
my $label	= 1;	# whether to diplay hostname: prefix on lines of output
my $timeout	= 10;	# timeout for expect statement, in seconds
my $force_yes	= 0;	# answer yes to confirmation prompt
my $verbose	= 0;	# don't trim any of the output
my $command;		# remote command to run 
my $username;		# remote login name to use
my $password;		# remote password to use to log in
my $ddnapiconf; 	# path to the credentials file 
my @systems;		# list of remote systems			
my @output;		# output data from telnet
my @errors;		# error messages from this program
my $delimiter = '%%%CUT%%%'; # used to delimit output of interest

MAIN: {
	# Process command line arguments.
	getargs();

	# Establish which credentials file to use.
	my $aix_ddnapiconf = "/opt/freeware/etc/ddnapi.conf"; 
	my $linux_ddnapiconf = "/admin/etc/ddnapi.conf"; 
	if ( ! defined $ddnapiconf )
	{
		if ( -T $aix_ddnapiconf &&
		     -r $aix_ddnapiconf )
			{ $ddnapiconf = $aix_ddnapiconf }
		elsif ( -T $linux_ddnapiconf &&
			-r $linux_ddnapiconf )
			{ $ddnapiconf = $linux_ddnapiconf }
		else
		{
			die "Failed to find a suitable DDN API credentials ",
			    "file.\nPlease specify the path to one using the -c ",
			    "option.\n";
		}
	}

	# Parse the credentials file.
	( $username, $password ) = parse_ddnapiconf( $ddnapiconf );

	# Do work.
	make_kids();
}

# make_kids(): Forks off a number of child processes equal to the lesser
#  of the fanout size or the number of remote hosts.  Waits to reap children
#  then loops until all systems have been processed. 
#
# args: none
# returns: none
sub make_kids
{
	my $system;
	my $parent = $$;
	my @kids;
	my $pid;

	for ( my $count = 0 ; ($count < $fanout) && $systems[0] ; $count++ )
	{	
		$system = shift @systems;
		$pid = fork;
		last unless $pid;
		push @kids, $pid;
	}

	if ( $pid ) # parent
	{
		# Wait until at least one kid has finished
		# working.
		my $gotone = 0;
		$SIG{USR1} = sub { $gotone++ };
		while ( ! $gotone ) { sleep 1 }

		# Kids must wait until called on to speak.
		# This avoids jumbled output due to
		# shared STDOUT.
		while ( my $kid = shift @kids )
		{
			# Children speak on SIGUSR1.
			kill "USR1", $kid;
			waitpid( $kid, 0 );

			# Fork another child if there are
			# more systems to process.
			if ( $system = shift @systems )
			{
				$pid = fork;
				last unless $pid;
				push @kids, $pid;
			}
		}
	}
	chores( $system, $parent ) unless $pid ; # child
}

# chores(): Constitues the work done by forked children. Does the telnet
# and displays the collected output when signalled.
#
# arg1: hostname of system to telnet to
# arg2: PID of parent
# 
# returns: none
sub chores {
	my ( $system, $parent ) = @_;
	my $myturn = 0;
	$SIG{USR1} = sub { $myturn = 1 };
	do_telnet($system);

	# Tell parent I'm done with my chores.
	kill "USR1", $parent;

	# Wait until I'm called on to speak.
	while ( ! $myturn ) { sleep 1 }

	print STDERR @errors if $errors[0];
	display($system, $label);
	exit;
}

# do_telnet(): Spawns the telnet process, sets the tty and output parameters,
#  calls expect_and_check to handle communications with the remote host, then
#  terminates the telnet program. Returns immediately if expect_and_check
#  returns 0. Submits an intentionally invalid command to delimit the output
#  of interest.
#
# args: the name of the system to connect to
# returns: none
sub do_telnet
{
	my $system = $_[0];
	my $exp = new Expect;
	$exp->slave->stty(qw(raw -echo));
	$exp->stty(qw(raw -echo));

	$exp->spawn("telnet $system")
		or die "$system: Cannot spawn telnet: $!\n";

	$exp->log_file( \&logger );

	expect_and_check( $exp, $system, '^login: $', $username ) || return;

	expect_and_check( $exp, $system, '^Password: $', $password ) || return;

	expect_and_check( $exp, $system, ': $', $delimiter ) || return;

	expect_and_check( $exp, $system, ': $', $command ) || return;

	if ( $force_yes )
	{
		my $old_timeout = $timeout;
		$timeout = 1;
		expect_and_check( $exp, $system, '\? \(y/N\):\s*$',
				  "y\n", 0 ) || return;
		$timeout = $old_timeout;
	}

	expect_and_check( $exp, $system, ': $', $delimiter ) || return;

	expect_and_check( $exp, $system, ': $', 'logout' ) || return;

	$exp->log_file( undef );
	$exp->soft_close();
}

# expect_and_check():  Waits for the remote system to produce the expected
#  pattern within the specified timeout value.  If it does, sends the
#  specified command.  Otherwise, display an appropriate error and abort.
#
# arg1: a perl-Expect object
# arg2: a remote system name
# arg3: a regular expression describing the pattern to expect
# arg4: the string to send to the remote system if the pattern is produced
# arg5: whether or not to die if the expected pattern is not produced
#       
# returns: 1 on error, otherwise 0
sub expect_and_check
{
	my ( $exp, $system, $expect_pattern, $send_string ) = @_;
	my $die_on_error = defined $_[4] ? $_[4] : 1; 
	my $got_an_error = 0;

	my (
		$matched_pattern_position,
		$error,
		$successfully_matching_string,
		$before_match,
		$after_match
	) = ($exp->expect($timeout, '-re', $expect_pattern));
	if ( $matched_pattern_position )
	{
		$exp->send("$send_string\n");
	}
	elsif ( defined $error && $die_on_error )
	{
		$got_an_error = 1;
		push(@errors, "$0: Error while expecting '$expect_pattern' from $system: '$error'.\n");
	}
	elsif ( $die_on_error )
	{
		$got_an_error = 1;
		push(@errors, "$0: Unknown error expecting '$expect_pattern' from $system.\n");
	}
	if ( $got_an_error )
	{
		$verbose = 1;
		push(@errors, "$0: Displaying output captured so far and exiting.\n");
		$exp->hard_close();
		return 0;
	}
	return 1;
}

# display(): Formats and prints the output produced by a remote system.  
#  Prefix each line with a label unless labels were disabled by the user.
#  Uses an intentionally invalid command to delimit the output of interest.
# 
# arg1: the name of the remote system
# arg2: boolean flag indicating whether to print labels
# arg3: optional file handle to print to, defaults to STDOUT
# 
# returns: none
sub display
{
	my $system = shift;
	my $label = shift;
	my $fh = defined $_[0] ? $_[0] : *STDOUT; 
	my @output = split( /$/sm, join('',@output));
	my $i;

	if ( $verbose ) # $verbose is global.
	{
		for ( $i = 0 ; $output[$i] ; $i++ )
		{
			print $fh "$system: " if $label;
			$output[$i] =~ s/[\r\n]//g; # Lines may begin with 
						    # newline due to split
						    # above.  Telnet adds
						    # carriage returns.
			print $fh "$output[$i]\n";
		}
		return;
	} 
	# Won't get here if $verbose is set.

	# Advance index until delimiter.
	for ($i=0;
	     $output[$i] && $output[$i] !~ /Invalid Command: $delimiter/;
	     $i++) {}

	# Advanced index until command.
	for ( ; $output[$i] && $output[$i] !~ /: $command/ ; $i++) {}

	# Skip the line with our command, then print output until delimiter.
	for ( $i++ ; $output[$i] && $output[$i] !~ /: $delimiter/ ; $i++ )
	{
		print $fh "$system: " if $label;
		$output[$i] =~ s/[\r\n]//g; # Lines may begin with 
					    # newline due to split
					    # above.  Telnet adds
					    # carriage returns.
		print $fh "$output[$i]\n";
	}
}

# logger(): Puts any output produced by the remote system into
#  the @output array for later processing.
# args: List of strings of output.
sub logger { push( @output, @_ ) }

# parse_ddnapiconf(): Reads the credentials file and returns what it finds
#  on the first and second lines.
#
# args: The path to the file.
# returns: The chomp()ed contents of the first and second lines of the file.
sub parse_ddnapiconf
{
	my $ddnapiconf = $_[0];
	open( DDNAPICONF, '<', $ddnapiconf )
		or die "Failed to open $ddnapiconf for reading: $!\n";

	my $username = <DDNAPICONF>;
	chomp($username);
	my $password = <DDNAPICONF>;
	chomp($password);
	
	close DDNAPICONF
		or die "Failed to close $ddnapiconf: $!\n";

	return( $username, $password );
}

# expand_quadrics_range(): expand nodelist in quadrics form
#
# args: string containing quadrics node range
# returns: list containing node names
sub expand_quadrics_range
{
        my ($list) = @_;
        my ($prefix, $ranges, $suffix) = split(/[\[\]]/, $list);
        return $list if (!defined $ranges);

        return map {"$prefix$_$suffix"}
                map { s/^(\d+)-(\d+)$/"$1".."$2"/ ? eval : $_ } 
                              split(/[,:]/, $ranges);
}

# getargs(): Process command line arguments, checking for usage errors.
#  Sets some key gloabl variables.
#
# args: none
# returns: none
sub getargs
{
	our( $opt_w, $opt_f, $opt_N, $opt_t, $opt_c, $opt_h, $opt_y, $opt_v );
	getopts('w:f:Nt:c:hvy');

	usage() if defined $opt_h;

	my $hostlist = '';
	if ( defined $opt_w ) { $hostlist = $opt_w }
	else { die "Please specify a hostlist using the -w option.\n" }

	# Replace ',' chars internal to "[]" with ':"
	while ($hostlist =~ s/(\[[^\]]*),([^\[]*\])/$1:$2/) {}
	@systems = map { expand_quadrics_range($_) } split /,/, $hostlist;
	
	$fanout = $opt_f if defined $opt_f;

	if ( defined $opt_c )
	{
		$ddnapiconf = $opt_c;
		unless ( -T $ddnapiconf &&
			 -r $ddnapiconf )
		{
			die "The specified credentials file '$ddnapiconf' ",
			    " is not a readable ASCII text file.  Aborting.\n";
		}
	}

	if ( defined $opt_t )
	{
		$timeout = $opt_t;
		unless ( $timeout =~ /^\d+$/ )
		{
			die "The specified timeout value '$timeout' is not ",
			    "an integer.  Aborting.\n";

		} 
	}

	$label = 0 if defined $opt_N;
	$force_yes = 1 if defined $opt_y;
	$verbose = 1 if defined $opt_v;

	if ( scalar @ARGV == 0 ) { die "No remote command specified.\n" }
	else { $command = join( ' ', @ARGV ) }
}

# usage(): Prints a usage summary and exits.
sub usage {
        print << "EOF";
Usage: $0 [-options] [remote command]

Runs 'remote command' via telnet on the specified target hosts.

-c  file           Specifies the path to a DDN credentials file, which must
		   be a 2 line plain text file containing the user name
		   on the first line and the password on the second line.
		   The default is /opt/freeware/etc/ddnapi.conf if it
		   exists, otherwise /admin/etc/ddnapi.conf is used.

-f  fanout         Specifies the maximum number of telnet processes to run in
                   parallel.  The default is 16 instances.

-h                 Displays this usage summary.

-N                 Disable hostname: prefix on lines of output.

-t  seconds	   Specifies the number of seconds to wait for the remote
                   system to produce an expected pattern before aborting.
		   Default is ten seconds.

-w  host,host,...  Sets the target system list using pdsh-style range syntax.

-v                 Be verbose; don't trim any of the output.

-y                 Expects a confirmation prompt following the command, and
                   sends a "y" in response.

EOF
	exit;
}
